import type { ConventionQuestion } from "@/types/conventions";

export const nextjsConventions: ConventionQuestion[] = [
  {
    id: "component-organization",
    category: "Code Organization",
    question: "How should components be organised?",
    description: "This determines your folder structure inside /components.",
    applicableTo: ["nextjs", "react-vite"],
    isRequired: true,
    options: [
      {
        id: "by-feature",
        label: "By feature (components/auth, components/dashboard)",
        description: "Groups components by the feature they belong to. Keeps related code together. Scales better for larger projects.",
        isRecommended: true,
        generatedText: "**Component Organisation**: By feature. Group components by the domain they serve (`auth/`, `dashboard/`, `patients/`). Shared primitives go in `components/ui/`. Each feature folder can contain its own hooks, utils, and types if needed.",
      },
      {
        id: "by-type",
        label: "By type (components/buttons, components/forms)",
        description: "Groups all similar components together. Works well for smaller projects with a reusable UI library.",
        isRecommended: false,
        generatedText: "**Component Organisation**: By type. Group components by function (`buttons/`, `forms/`, `layout/`, `cards/`). Each component gets its own file. Shared types go in a top-level `types/` directory.",
      },
      {
        id: "flat",
        label: "Flat (all components in one folder)",
        description: "Simple and easy to navigate for small projects. Gets messy past ~20 components.",
        isRecommended: false,
        generatedText: "**Component Organisation**: Flat structure. All components live in `components/` with no subfolders. Use clear, descriptive file names to keep things findable. Move to feature-based organisation if the folder exceeds ~20 files.",
      },
    ],
  },
  {
    id: "data-fetching",
    category: "Data Fetching",
    question: "How should data be fetched?",
    description: "Next.js offers multiple patterns. Pick one primary approach for consistency.",
    applicableTo: ["nextjs"],
    isRequired: true,
    options: [
      {
        id: "server-components",
        label: "Server Components (recommended for App Router)",
        description: "Fetch data directly in server components. Simpler code, better performance, but requires understanding the server/client boundary.",
        isRecommended: true,
        generatedText: "**Data Fetching**: Use Server Components as the default. Fetch data at the page or layout level using `async` server components. Only use `\"use client\"` when interactivity is required. Pass server-fetched data to client components as props. Never fetch data in client components unless it's for real-time or user-triggered updates.",
      },
      {
        id: "client-hooks",
        label: "Client-side with hooks (SWR, React Query, useEffect)",
        description: "Traditional React pattern. All fetching happens in the browser. More familiar but misses Next.js performance benefits.",
        isRecommended: false,
        generatedText: "**Data Fetching**: Client-side fetching using SWR or React Query hooks. All data fetching happens in client components. API routes (`app/api/`) serve as the backend interface. Use loading states and error boundaries for all fetched data.",
      },
      {
        id: "server-actions",
        label: "Server Actions (for mutations)",
        description: "Use Server Actions for form submissions and data mutations. Pairs well with Server Components for reads.",
        isRecommended: false,
        generatedText: "**Data Fetching**: Server Components for reading data, Server Actions for mutations. Define actions in separate files with `\"use server\"`. Call actions from forms or client components using `useActionState`. Validate all inputs server-side.",
      },
    ],
  },
  {
    id: "error-handling",
    category: "Error Handling",
    question: "How should errors be handled?",
    description: "Consistent error handling prevents cascading failures and confusing AI output.",
    applicableTo: ["nextjs", "react-vite", "express"],
    isRequired: true,
    options: [
      {
        id: "error-objects",
        label: "Return error objects ({ success, data, error })",
        description: "Functions always return a result object. Callers check the success flag. Predictable and explicit — no try/catch needed at call sites.",
        isRecommended: true,
        generatedText: "**Error Handling**: Return result objects, never throw for expected errors. All functions that can fail return `{ success: true, data }` or `{ success: false, error: string }`. Use TypeScript discriminated unions. Only throw for truly unexpected/programmer errors. Use `error.tsx` boundary files for unrecoverable UI errors.",
      },
      {
        id: "throw-exceptions",
        label: "Throw exceptions (try/catch pattern)",
        description: "Functions throw on failure. Callers use try/catch. Traditional pattern but can lead to uncaught errors.",
        isRecommended: false,
        generatedText: "**Error Handling**: Throw exceptions for errors. Use try/catch at call sites. Define custom error classes for different error types. Use React error boundaries (`error.tsx`) to catch render errors. Log all caught errors.",
      },
    ],
  },
  {
    id: "routing-pattern",
    category: "Routing",
    question: "How should routes be structured?",
    description: "Next.js App Router uses file-based routing. This decides how you organize your route segments.",
    applicableTo: ["nextjs"],
    isRequired: false,
    options: [
      {
        id: "feature-routes",
        label: "Feature-based route groups",
        description: "Use route groups (parentheses folders) to organize by feature: (auth), (dashboard), (marketing). Keeps related pages together.",
        isRecommended: true,
        generatedText: "**Routing**: Use route groups to organise by feature: `app/(auth)/login/`, `app/(dashboard)/patients/`, `app/(marketing)/`. Each group can have its own layout. Use parallel routes for complex layouts.",
      },
      {
        id: "flat-routes",
        label: "Flat route structure",
        description: "All routes at the top level of app/. Simple but can get crowded.",
        isRecommended: false,
        generatedText: "**Routing**: Flat route structure. All pages directly under `app/`: `app/login/`, `app/dashboard/`, `app/patients/`. Use shared layouts via `layout.tsx` at the appropriate level.",
      },
    ],
  },
  {
    id: "state-management",
    category: "State Management",
    question: "How should client-side state be managed?",
    description: "For state that can't be server-rendered (forms, UI state, real-time data).",
    applicableTo: ["nextjs", "react-vite"],
    isRequired: false,
    options: [
      {
        id: "react-context",
        label: "React Context + useReducer",
        description: "Built-in React state management. No extra dependencies. Good for small-to-medium apps.",
        isRecommended: true,
        generatedText: "**State Management**: Use React Context + `useReducer` for shared client state. Keep contexts small and focused (e.g., `AuthContext`, `ThemeContext`). For page-level state, use `useState`. Avoid prop drilling by co-locating state near where it's used.",
      },
      {
        id: "zustand",
        label: "Zustand",
        description: "Lightweight state management with a simple API. Good for medium-to-large apps.",
        isRecommended: false,
        generatedText: "**State Management**: Use Zustand for global client state. Create one store per domain (`useAuthStore`, `useUIStore`). Keep stores thin — most data should come from the server. Use `useState` for component-local state.",
      },
      {
        id: "url-state",
        label: "URL state (searchParams)",
        description: "Store state in the URL for shareable, bookmarkable pages. Use nuqs or manual searchParams.",
        isRecommended: false,
        generatedText: "**State Management**: Prefer URL state via `searchParams` for filterable/sortable views. Use `useState` for ephemeral UI state. Use React Context only for truly global state like auth. URL state makes pages shareable and bookmarkable.",
      },
    ],
  },
];
